# Apunte: Estructura de datos fundamentales

## 1. Arreglos
### Definici√≥n
Los arreglos son estructuras de datos que almacenan secuencias de elementos del mismo tipo. Son ideales para aplicaciones donde se necesita guardar una colecci√≥n ordenada de datos.
- sintaxis basica:
```java
// Crear un arreglo vac√≠o:
elementType[] arrayName = new elementType[length];  

// Inicializar con valores:
elementType[] arrayName = {valor0, valor1, ..., valorN};  
```
- Ejemplo:
```java
int[] scores = {750, 1105, 720, 660}; // Almacena puntajes.
String[] players = {"Rob", "Mike", "Anna"}; // Almacena nombres.
```
- Ordenamiento

Este es uno de tantos metodos de ordenamientos de un arreglo.
```java
public class OrdenamientoBurbuja {
    public static void main(String[] args) {
        int[] arreglo = {5, 2, 9, 1, 5, 6};

        // Ordenamiento burbuja
        for (int i = 0; i < arreglo.length - 1; i++) {
            for (int j = 0; j < arreglo.length - 1 - i; j++) {
                if (arreglo[j] > arreglo[j + 1]) {
                    // Intercambiar
                    int temp = arreglo[j];
                    arreglo[j] = arreglo[j + 1];
                    arreglo[j + 1] = temp;
                }
            }
        }

        // Mostrar arreglo ordenado
        System.out.println("Arreglo ordenado:");
        for (int num : arreglo) {
            System.out.print(num + " ");
        }
    }
}
```
### M√©todos de `java.util` para **Arreglos** y n√∫meros **Random**

### üìó M√©todos para Arreglos (`Arrays`)
- `equals(A, B)`
- `fill(A, x)`
- `copyOf(A, n)`
- `copyOfRange(A, s, t)`
- `toString(A)`
- `sort(A)`
- `binarySearch(A, x)`

### üîµ M√©todos para n√∫meros Random (`Random`)
- `nextBoolean()`
- `nextDouble()`: entre 0.0 y 1.0
- `nextInt()`
- `nextInt(n)`: entre 0 y n
- `setSeed(s)`: long `s`

### Ejemplo de su uso:
```java
import java.util.Arrays;
import java.util.Random;

public class EjemploJavaUtil {
    public static void main(String[] args) {
        // Creamos un arreglo de tama√±o 5 y lo llenamos con el n√∫mero 3
        int[] arreglo = new int[5];
        Arrays.fill(arreglo, 3);
        System.out.println("Arreglo con fill: " + Arrays.toString(arreglo));

        // Reemplazamos el arreglo con n√∫meros aleatorios entre 0 y 9
        Random rand = new Random();
        for (int i = 0; i < arreglo.length; i++) {
            arreglo[i] = rand.nextInt(10); // n√∫meros entre 0 y 9
        }
        System.out.println("Arreglo con n√∫meros aleatorios: " + Arrays.toString(arreglo));

        // Copiamos el arreglo
        int[] copia = Arrays.copyOf(arreglo, arreglo.length);
        System.out.println("Copia del arreglo: " + Arrays.toString(copia));

        // Comparamos los dos arreglos
        System.out.println("¬øSon iguales? " + Arrays.equals(arreglo, copia));

        // Ordenamos el arreglo
        Arrays.sort(arreglo);
        System.out.println("Arreglo ordenado: " + Arrays.toString(arreglo));

        // B√∫squeda binaria de un n√∫mero (por ejemplo, 5)
        int posicion = Arrays.binarySearch(arreglo, 5);
        if (posicion >= 0) {
            System.out.println("El n√∫mero 5 se encuentra en la posici√≥n: " + posicion);
        } else {
            System.out.println("El n√∫mero 5 no se encuentra en el arreglo.");
        }

        // Ejemplos adicionales con Random
        System.out.println("Random boolean: " + rand.nextBoolean());
        System.out.println("Random double: " + rand.nextDouble()); // entre 0.0 y 1.0
    }
}
```
## 2. Listas 

### *Listas Simplemente Enlazadas*
**‚úÖ Definici√≥n:**
Una lista enlazada simple es una estructura de datos lineal compuesta por nodos. Cada nodo contiene: 
- Un dato.

- Una referencia (o puntero) al siguiente nodo de la lista.

**üîß Caracter√≠sticas:**
- El primer nodo se llama cabeza (head).
- El √∫ltimo nodo apunta a null o None (no hay m√°s elementos).
- Se recorre de forma secuencial, s√≥lo hacia adelante.
- No tiene un tama√±o fijo como los arrays.

**üì¶ Estructura de un Nodo:**
```
+----------+------------+
|  Dato    |  Siguiente |
+----------+------------+
```


**üîÅ Operaciones B√°sicas:**
- Insertar: al principio, al final o en una posici√≥n espec√≠fica.

- Eliminar: un nodo por valor o por posici√≥n.

- Buscar: recorrer la lista hasta encontrar un valor.

- Recorrer: visitar cada nodo en orden.

![Lista Enlazada Simple](imagenes/ListaSimplementeEnlazada.png)

### *Lista Enlazada Circular*
**‚úÖ Definici√≥n:**
Una lista enlazada circular es una variante de la lista enlazada en la que el √∫ltimo nodo no apunta a null, sino que vuelve al primer nodo, formando un ciclo cerrado.

üîß **Caracter√≠sticas:**
- El √∫ltimo nodo apunta al primero, formando un bucle.
- Puede ser simple (cada nodo apunta solo al siguiente) o doblemente enlazada circular.
- Se puede recorrer la lista de forma continua sin encontrar un ```null```.
- Se necesita tener cuidado para evitar bucles infinitos al recorrerla.

üîÅ **Operaciones B√°sicas:**
- Insertar: similar a la lista simple, pero al insertar al final, hay que actualizar el puntero del √∫ltimo nodo para que apunte al nuevo nodo y este al primero.

- Eliminar: cuidado especial al borrar el √∫nico nodo o el nodo al que apunta el √∫ltimo.

- Recorrer: se recorre hasta volver al nodo de inicio (generalmente head).

![Lista Enlazada Circular](imagenes/ListaCircular.png)
### *Lista Doblemente Enlazada* 
‚úÖ **Definici√≥n:**
Una lista doblemente enlazada es una estructura de datos lineal donde cada nodo contiene dos referencias:

- Una al nodo siguiente.

- Una al nodo anterior.

Esto permite recorrer la lista en ambas direcciones.

üîß **Caracter√≠sticas:**
- Hay un puntero al siguiente nodo y uno al anterior.

- El primer nodo tiene su referencia anterior como null.

- El √∫ltimo nodo tiene su referencia siguiente como null.

- Tambi√©n existe la versi√≥n circular (el √∫ltimo apunta al primero y viceversa).

üì¶ **Estructura de un Nodo:**

```
+-----------+----------+------------+
| Anterior  |   Dato   |  Siguiente |
+-----------+----------+------------+
```


üîÅ **Operaciones B√°sicas:**
- Insertar: se puede insertar antes o despu√©s de un nodo con facilidad.

- Eliminar: m√°s eficiente porque se puede acceder al nodo anterior directamente.

- Recorrer hacia adelante y hacia atr√°s.

![Lista Doblemente Enlazada](imagenes/ListaDoblementeEnlazada.png)


